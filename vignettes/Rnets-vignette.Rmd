---
title: "Rnets Vignette"
author: "WJ Love"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{"Rnets Vignette"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
## Introduction

This package provides a mostly automated analysis pipeline for translating antimicrobial resistance (AMR) data from bacterial populations into network models. Representing resistance relationships as networks facilitates visualization and understand of this multivariate data and opens up a novel set of analytic approaches. The focus of the package is to leverage existing and accessible phenotypic resistance data from clinical antimicrobial susceptibility testing (AST) to identify correlated resistances. Correlations with other factors, e.g., patient characteristics and additional isolate details, can also be included in the networks.

## Networks and Sparsity
The networks models created by this package are probabalistic graphical models (PGMs), more specifically Markov random fields (MRF). MRFs are undirected graphical models where the vertex set is defined by a set of random variables and the edge set is defined by non-zero partial correlations between variables in the dataset. Sparse MRFs of AMR data are resistance relationship network models, which is shorted to 'R-nets'. The R-nets represent the estimated correlations in resistances across the population from which the AST results were drawn.

_Sparsity_ is a concept in network models desribing how many or how few links, or _edges_, exist between the units, or _vertices_, of the network. A network in which all possible edges exist is referred to as dense. Sparsity is an appealing characteristic because sparse networks are much easier to interpret than completely dense networks. An MRF may be made sparse by reducing trivially small partial correlations to 0. Several approaches to this problem have been described, and we employ here the graphical least absolute shrinkage and selection operator (gLASSO). This method applies an L~1~ penalty when estimating the inverse covariance matrix (also refered to as the 'precision matrix') to increase it's sparsity. Higher L~1~ values leads to fewer edges and a sparser network and the graph is empty when $L_1 \geq max(|\sigma_{ij}|)$, i.e., there a no edges and all the variables appear to be conditionally independent. 

The analysis pipeline can be summarized as follows:
$$\Large D_{n \times k} \underset{cor}{\rightarrow} \Sigma_{k \times k} \underset{glasso}{\rightarrow} \Theta_{k \times k} \underset{std'ize}{\rightarrow}\Omega_{k \times k} \underset{igraph}{\rightarrow}R(V, E)$$
Where...

* $D$ is the data matrix with _n_ observations (single isolates) over _k_ variables (Resistances tested).
* $\Sigma$ is the empirical correlation/covariance matrix for the _k_ variables in _D_.
* $\Theta$ is the penalized precision matrix.
* $\Omega$ is the partial correlation matrix, estimated as $\omega_{ij}=\frac{-\theta_{ij}}{\sqrt{\theta_{ii} \theta_{jj}}}|i\neq j$
* $R$ is the network defined by the two sets:
    + The vertex set $V$, with $|V| = k$ vertices and
    + The edge set $E$, with $|E| = m$edges.
    
The MRF can be thought of as a convenient way of visualizing the penalized $\Omega$. The estimated structure is conditional on the selected L~1~. `L1Selection()` discussed below uses a resampling and stability method assist in selecting an L~1~ penalty objectively.

In an R-net, phenotypical resistances and other cofactors are represented as vertices, i.e., the observed MICs and cofactors are the random variables in the dataset represented by the R-net. The edges in an R-net represent resistances (or other cofactors) that have non-zero correlations after accounting for all the other covariances in the data. The significance of the non-zero partial correlations are that selecting for one resistance may indirectly select for the correlated resistance. For example, if AMP--TET edge is found to have $\omega \geq 0$ for a population of bacteria, it indicates that environments that select for increased AMP, e.g., therapeutic use of ampicillin, may indirectly select for increased TET as well. 

## Under the hood

`Rnets` relies heavily on the `glasso` and `igraph` packages. `glasso`, maintained by R. Tibshirani^[Friedman, Hastie & Tibshirani. "Sparse inverse covariance estimation with the graphical lasso." _Biostatistics_ (2007)], provides the eponymous function for estimating sparse precision matrices. `igraph` is one of the most popular libraries on CRAN for working with network data and was developed by Gabor Csardi and Tamas Nepusz^[Gabor Csardi and Tamas Nepusz. "The igraph software package for complex network research." _InterJournal_ (2006)]. `Rnets` makes extensive use of the resources in `igraph` to store, analyze, and manipulate the estimated MRFs.

## Using the Rnets package

This package is designed to intake processed AST results and return usable networks for further analysis. The work flow in R can be generalized 

1. Import and process AMR data (This is outside the scope )
2. Use `L1selection()` or another method to select appropriate penalty
3. Use `Rnet()` to estimate the MRF structures
  + Assign metadata to rnet object as needed
4. Visualize and analyze the R-nets

####Example data
The example dataset `NARMS_EC_DATA` is included in the package and contains a subset of AMR data from _E. coli_ isolates collected by the FDA & USDA as part of the National Antimicrobial Resistance Monitoring System^[<https://www.fda.gov/animalveterinary/safetyhealth/antimicrobialresistance/nationalantimicrobialresistancemonitoringsystem/>].

```{r, echo = FALSE, results = 'hide', message = F}
library(Rnets)
attach(Rnets::NARMS_EC_DATA)

#Define the set of antimicrobials to include in the Rnet
ABX_LIST <- c('AMC', 'AXO', 'TIO', 'CIP', 'TET', 'STR', 'GEN', 'CHL')
```

####Notes on data processing and analysis
Due to the variety of storage formats for AMR data, data preparation is beyond the scope of `Rnets`. Typically, MIC results from AST will be reported with an inequality sign and a numeric value, e.g., `= 16` or `> 4`. The functions in `Rnets` require only numeric values, so some degree of editing will often be required to make AST results usable. For entries preceeded by `=`, `<`, or `<=`, we suggest simply trimming the sign. However, `>` and `>=` indicate that the MIC was in excess of highest tested concentation. Therefore, an MIC reported as `> 4` represents a greater resistance than `= 4`. In these cases, we suggest doubling  MIC values reported as `>` or `>=`, e.g. `> 4` is transformed to `8` for analysis. Doubling the MIC aims to represent the higher resistance as being in the next higher two-fold concentration that was not tested.

We suggest using the non-parametric estimators for correlation such as Kendall's $\tau_b$ or Spearman's $\rho$ to estimate $\Sigma$ instead of Pearson's method. The gLASSO method was orignally described for Gaussian data, but MICs rarely conform to a normal distribution. Therefore using Pearson's method, which assumes Gaussianity, to estimate $\Sigma$ may result in biased results. The non-parametric rank-based estimators have been shown to produce less biased with gLASSO when the underlying data is not Gaussian. The user can choose any of the three methods to estimate $\Sigma$, but `Rnet()` defaults to Spearman's (`Rnet(..., cor_method = 's')`) and Kendall's $\tau_b$ (`Rnet(..., cor_method = 'k')`) is suggested when some of the variables are binomial. When parametric tests are needed, we suggest using a `log2(MIC)` transformation to reduce skewness.

### Penalty Selection

Several methods have been proposed to select the 'appropriate' L~1~ penalty, represented by $\lambda$, to induce sparsity in MRFs. In general, $\lambda$ should be high enough to remove trivially small partial correlations while leaving intact stronger partial correlations that are presumbly caused by genetic associations. `L1Selection` implements the StARS method described by Liu, Roeder, and Wasserman (2010)^[Stability Approach to Regularization Selection (StARS) for High Dimensional Graphical Models. _Advances in Nerual Information Processing Systems 23_ (2010)]. Briefly, this method estimates MRFs using multiple subsets sampled without replacement from the empirical data over a range of $\lambda$ values. Individual edges/partial correlations from the subset-derived MRFs are evaluated for stability (defined as the std. deviation of the proportion of subsets in which they appear), and a score _D_ is assigned for each tested value of $\lambda$ based on the sum of stabilities for all edges over all subsets given the respective penalty. The suggested $\lambda$ value is the lowest value for which _D_ is below some threshold, typically 0.05. The goal is to find the densest network that is also stable across most data subsets.

`L1Selection` defaults to a subsample size `n_b` of half the dataset, but smaller subsamples are typically appropriate. Liu, Roeder, and Wasserman suggest $n_b = 10\sqrt{n}$. `n_b` can be set to a proportion of the sample size by setting `n_b < 1` or as a set number of individuals with `1 < n_b < n`.

```{r}
EC_all_L1Selection <- L1Selection(
            x = NARMS_EC_DATA, 
            L1_values = seq(0.05, 0.45, 0.05),
            n_b = 1500,
            vert = ABX_LIST,
            verbose = F
            )

summary(EC_all_L1Selection)
```
Given these results, the suggested regularization penalty would be $\lambda$ = 0.15, since StARS_D > 0.05 at $\lambda$ = 0.10.

NOTE: The resampling approach can be time consuming large datasets, i.e. datasets with many observations or many variables.

### Network Estimation
`Rnet()` is the core function of this package. This function intakes a data.frame containing the AMR data, the L~1~ penalty, and other options and produces one of several  object classes containing the processed network and associated attributes (the specific class is determined by the specification of the option ```subset``` argument). 


####Basic Rnets
The simplest way to use ```Rnet()``` is to not specify ```subset```, in which case all the available data is used to estimate a single network. This creates an S4 object of class ```rnetBasic```.

```{r}
#Estimate the Rnet
EC_all_Rnet <- Rnets::Rnet(x = NARMS_EC_DATA, L1 =  0.15, vert = ABX_LIST)
                
#View Results
summary(EC_all_Rnet)
```

####Subset Rnets
In many cases, it is reasonable to believe that subpopulations in the data may have different partial correlation structures, in which case it is appropriate to estimate a seperate Rnet for each subpopulation. To estimate the network for a single subpopulation, an expression defining it should be passed to the function using the  optional `subset` arugument. For example, to create an Rnet for the isolates from 2008, add `subset = expression(Year == 2008)`. When `subset` is an expression, `Rnet()` returns an `rnetSubset` object.
```{r}
EC_2008_Rnet <- Rnets::Rnet(x = NARMS_EC_DATA, L1 =  0.15, vert = ABX_LIST, subset = expression (Year == 2008))

summary(EC_2008_Rnet)
```

####Stratified Rnets
It is possible to create multiple R-nets with a single function call. To do so, `subset` can be defined as one of columns of `x`,  specifically `subset = 'column_name'`. In this case `Rnet()` will estimate a seperate Rnet for each unique level of `x$column_name`, and will return an object of class `rnetStrata`.
```{r}
EC_byYear_Rnet <- Rnets::Rnet(x = NARMS_EC_DATA, L1 =  0.15, vert = ABX_LIST, subset = 'Year')

summary(EC_byYear_Rnet)
```
### Rnet objects

The results of `Rnet()`, in addition to the input arguments are stored in the S4 classes `rnetBasic`, `rnetSubset`, and `rnetStrata`. All three output classes inherit from `rnetInput`, but the user shouldn't have reason to interact with this class. The output class returned is determined by the optional `subset` arugment as discussed above. A complete accounting of the objects' slots are provided in the help files, but several particularly useful slots for each of the classes are described below.

####rnetBasic

The slot `rnetbasic.obj@Omega` contains the estimated penalized partial correlation matrix, $\Omega$. This can be used as a weighted adjacency matrix.

The slot `rnetbasic.obj@R` contains the `igraph` object representing the estimated MRFs. This slot can be accessed and manipulated like any other `igraph` object:

* `igraph::ecount(rnetbasic.obj@R)`
* `igraph::set_vertex_attr(graph = rnetbasic.obj@R, name = 'vertex.color', value = 'red')`
* `plot.igraph(x = rnetbasic.obj@R)`

The slot `rnetbasic.obj@layout` contains a matrix of x & y coordinates for placing the vertices for `rnetbasic.obj@R`. Called by the `plot(x)` generic method when `class(x) = "rnetBasic"`, but is not used by `plot.igraph()`. 

####rnetSubset
This class inherits from `rnetBasic` and gains the `@subset` slot, which contains the expression used to define the subset.

####rnetStrata
`rnetStrata` does not inherit from either of the two other output classes. 

The slot `rnetstrata.obj@stratify_by` contains the string matching column in `x` used for stratification.

The slot `rnetstrata.obj@R_set` is a list of `rnetSubset` objects. The names of the list's elements match the value defining the stratum, i.e., `names(rnetstrata.obj@R_set) <- unique(x$stratify_by)`. A specific `rnetStrata` object in the list can be accessed using `rnetstrata.obj@R_set[['subset_val']]`.

The slot `rnetstrata.obj@E_aggr` contains a matrix of estimated penalized partial correlation values for each observed edge (rows) in each R-net (columns). 

### Assigning network attributes

Vertices and edges in `igraph` objects can be assigned a variety attributes, also referred to a _metadata_,  that are useful for decorating and analyzing the networks. Immeadiately after being output from `Rnet()`, the network objects in `rnetbasic@R` have one vertex attribute (`name`, corresponding to the elements of the _vertices_ argument) and one edge attribute (`omega`, the edges' estimated penalized partial corrleation). 

Users have the option to access, add to, and remove from an rnet object's graphical metadata using `igraph` functions.  Examples include:

* `V(rnetbasic.obj@R)$name` to access vertex names
* `rnetbasic.obj@R <- set_vertex_attr(graph = rnetbasic.obj@R, name = 'vertex.shape', 'square')` to set all vertices' to have a square shape
* `E(rnetbasic.obj@R)$edge.color <- 0` to make edges be colored black.

Assigning each attribute individually can be time-consuming, so `Rnets` provides `Assign_Emetadata` and `Assign_Vmetadata` to more efficiently assign vertex and vertex attributes, respectively. These functions match vertex or edge attributes to a column in a data.frame, and then assign corresponding values as attributes. 

####Assign_Vmetadata()

This method is used to simultaneously assign multiple vertex attributes to an `igraph` network object, including those stored in `rnetbasic@R`. The vertex attributes are stored in a data.frame that can be viewed easily. `Rnets::V_ATTRS` is included as example of attribute table.
```{r}
Rnets::V_ATTRS[1:10,]
```
The first column contains NARMS' 3-letter code for the resistance and the other columns include the drug's full name, a code for the drug class ("AMINO" for aminoglycoside, "FQ" for fluoroquinolones, etc.), a color to use for vertices of each class, and the label text color for the vertex.

We could use a series of four `V(rnetbasic.obj@R)$attr` or `set_vertex_attr()` calls (one for each additional attribute to add), but it is more efficient to use `Assign_Vmetadata`. We will the vertex attribute `name`( `V(rnetbasic.obj@R)$name`)  to entries `V_ATTRS$Code` to assign the data. The follwoing code is used to assign characteristics to the `EC_2008_Rnet` created above.

```{r}
Assign_Vmetadata(EC_2008_Rnet, V_ATTRS, match_attr = 'Code', V_match_attr = 'name')

```
The function returns a table of the assigned characteristics for transparency. It is unneccesary to include the final argument in this case since `V_match_attr` defaults to the `name` attribute, but it is explictly included for clarity. Attibutes can be assigned using other vertex attribues, including those assigned previously with  `Assign_Vmetadata(x, ...)`.

Note that the it is not neccesary to define a new object or over-write the original object to assign the new attributes with `Assign_Vmetadata`. A new object can be created, or the old one redefined, e.g., `new_R_obj <- Assign_Vmetadata(EC_2008, V_ATTRS, match_attr = 'Code'`. However, the first part of the line `new_R_obj <- Assign_Vmetadata` can be omitted and the metadata will be added to the object represented by `x`. This feature is included to reduce redundant code and can be suppressed by including `reassign = F` as an argument.

####Assign_Emetadata()

This method is used to simulataneously assign multiple edge attributes to an `igraph` network object  based on a continuous edge attribute. in rnet objects, the attribute is typically `E(rnetbasic@R)$omega`, the penalized partial correlation between the two vertices/variables. Again, we include an example data.frame of edge attributes.
```{r}
Rnets::E_ATTRS
```
This frame is much simpler than `V_ATTRS`



### Network visualization

Two primary methods are used to visualize the R-nets: generic `plot()` methods for visualizing individual networks and `Rnet_Heatmap()` for comparing multiple graphs. 

#### Rnet plot() methods

Since `@R` in `rnetBasic` and `rnetSubset` objects and elements of `@R_set` in `RnetStrata` objects store `igraph` class objects, they can be plotted using the respective S3 `plot()` method, e.g., `plot.igraph(rnetbasic.obj@R)`. `plot.igraph()` allows the user to assign arguments controling the appearance of vertices (e.g., vertex.size, vertex.color), edges (e.g. edge.lty, edge.width), and the layout of the graph (see `?igraph.plotting` for more details and a complete of parameters). Additionally, `plot.igraph()` will automatically identify any edge and vertex attribute names matching parameter names and apply those in place of undeclared arguments.

`Rnets` also includes an S4 `plot()` method for `rnetBasic` objects (and `rnetSubset` objects via inheritance). This method accepts all the standard and igraph plotting arguments for `plot.igraph()`. Arguments declared in the function call will override the values in `V(x@R)$attr` and `E(x@R)$attr`. For easy comparison, the graph layouts are kept the same between calls.

A simple, undecorated graph can be drawn as follows:
```{r}

```

#### Arranging network layouts

The layout for plotting networks in an Rnet object can be defined at creation, using the optional `layout` argument for `Rnet()` to define a layout matrix, or at any later time by editing an existing rnet object's layout matrix in `@layout` slot. 

The `igraph` package also includes `tkplot()` and its associated functions for manually laying out graphs. `tkplot()` creates an interative canvas in a seperate window to place (click-and-drag) vertices to create custom layouts, which can then be captured with `tk_coords()`. More information about these functions can be found in `?tkplot`.



#### Rnet heatmaps

Heatmaps can be used to compare the edges in multiple Rnets. In these plots, the penalized 

### Network analysis


